# -*- coding: utf-8 -*-
"""ORIE3120.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qG_YM53cLQy76GST7DHMm_UcipRW0xKH
"""

import pandas as pd
import numpy as np

df = pd.read_csv('nyc_cleaned_airbnb_NEWEST.csv')
print(df.head())

#What pricing strategy should a host use to maximize revenue while maintaining occupancy?
#group by neighbourhood_group_cleansed to find avg price of airbnb in each neighborhood
df.groupby('neighbourhood_group_cleansed')['price'].mean()

# tests diff prices against estimated_nights_booked_365_model
df['price'] = df['price'].astype(float)
df['estimated_nights_booked_365_model'] = df['estimated_nights_booked_365_model'].astype(float)
df['avg_revenue'] = df['price'] * df['estimated_nights_booked_365_model']
print(df['avg_revenue'])
df.groupby('neighbourhood_group_cleansed')['avg_revenue'].mean()

# Load the dataset
df = pd.read_csv("nyc_cleaned_airbnb_NEWEST.csv")

# Ensure price and estimated nights are floats
df['price'] = df['price'].astype(float)
df['estimated_nights_booked_365_model'] = df['estimated_nights_booked_365_model'].astype(float)

# Compute average revenue
df['avg_revenue'] = df['price'] * df['estimated_nights_booked_365_model']

# Group by neighborhood and room type, compute average revenue
avg_revenue_grouped = (
    df.groupby(['neighbourhood_group_cleansed', 'room_type'])['avg_revenue']
    .mean()
    .reset_index()
    .sort_values(by='avg_revenue', ascending=False)
)

avg_revenue_grouped

#calculate revenue to occupancy ratio
df['revenue_to_occupancy_ratio'] = df['avg_revenue'] / df['estimated_nights_booked_365_model']
print(df['revenue_to_occupancy_ratio'])

df.groupby('neighbourhood_group_cleansed')['revenue_to_occupancy_ratio'].mean()

df.groupby('room_type')['revenue_to_occupancy_ratio'].mean()


import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error


df = pd.read_csv('nyc_cleaned_airbnb_NEWEST.csv')
df = df[['neighbourhood_group_cleansed', 'room_type', 'accommodates',
         'bathrooms', 'bedrooms', 'beds', 'minimum_nights', 'availability_365',
         'review_scores_rating', 'instant_bookable', 'reviews_per_month', 'price']].dropna()
df['price'] = df['price'].astype(float)


feature_cols = ['neighbourhood_group_cleansed', 'room_type',
                'accommodates', 'bathrooms', 'bedrooms', 'beds',
                'minimum_nights', 'availability_365',
                'review_scores_rating', 'instant_bookable', 'reviews_per_month']
X = df[feature_cols]
y = df['price']

#train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)


numeric_feats = ['accommodates', 'bathrooms', 'bedrooms', 'beds',
                 'minimum_nights', 'availability_365', 'review_scores_rating', 'reviews_per_month']
cat_feats = ['neighbourhood_group_cleansed', 'room_type', 'instant_bookable']

preprocessor = ColumnTransformer([
    ('num', StandardScaler(), numeric_feats),
    ('cat', OneHotEncoder(drop='first', sparse_output=False), cat_feats)
])


pipeline = Pipeline([
    ('prep', preprocessor),
    ('reg', LinearRegression())
])


pipeline.fit(X_train, y_train)
y_pred = pipeline.predict(X_test)

mse = mean_squared_error(y_test, y_pred)
rmse = mse ** 0.5
print(f"Test RMSE: {rmse:.2f}")

coef = pipeline.named_steps['reg'].coef_
oh = pipeline.named_steps['prep'].named_transformers_['cat']
cat_names = oh.get_feature_names_out(cat_feats)
feature_names = numeric_feats + list(cat_names)

coef_df = pd.DataFrame({
    'feature': feature_names,
    'coefficient': coef
}).sort_values(by='coefficient', key=lambda s: s.abs(), ascending=False)

print(coef_df.to_markdown(index=False))

#EDITED MONTE CARLO SIMULATION


#Keep previous simulation logic
df = pd.read_csv("nyc_cleaned_airbnb_NEWEST.csv")
df = df.dropna(subset=['price', 'estimated_nights_booked_365_model', 'neighbourhood_group_cleansed', 'room_type'])

df['price'] = df['price'].astype(float)
df['estimated_nights_booked_365_model'] = df['estimated_nights_booked_365_model'].astype(float)

#Simulate revenue using actual avg price and variable estimated nights
grouped = df.groupby(['neighbourhood_group_cleansed', 'room_type'])

monte_results_trimmed = []
for (neigh, room), group in grouped:
    avg_price = group['price'].mean()
    avg_nights = group['estimated_nights_booked_365_model'].mean()

    simulated_revenue = np.random.normal(loc=avg_nights, scale=5, size=1000) * avg_price
    simulated_revenue = np.clip(simulated_revenue, 0, None)

    monte_results_trimmed.append({
        'neighbourhood_group_cleansed': neigh,
        'room_type': room,
        'avg_price_used': avg_price,
        'avg_nights_used': avg_nights,
        'simulated_mean_revenue': simulated_revenue.mean(),
        'simulated_std_revenue': simulated_revenue.std()
    })

simulated_only_df = pd.DataFrame(monte_results_trimmed)
simulated_only_df = simulated_only_df.sort_values(by='simulated_mean_revenue', ascending=False)

simulated_only_df

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns


df = pd.read_csv("nyc_cleaned_airbnb_NEWEST.csv")
df = df.dropna(subset=['price', 'estimated_nights_booked_365_model', 'neighbourhood_group_cleansed', 'room_type'])


df['price'] = df['price'].astype(float)
df['estimated_nights_booked_365_model'] = df['estimated_nights_booked_365_model'].astype(float)

#group data and simulate Monte Carlo revenue with variability
grouped = df.groupby(['neighbourhood_group_cleansed', 'room_type'])
monte_results = []

for (neigh, room), group in grouped:
    avg_price = group['price'].mean()
    avg_nights = group['estimated_nights_booked_365_model'].mean()
    simulated_revenue = np.random.normal(loc=avg_nights, scale=5, size=1000) * avg_price
    simulated_revenue = np.clip(simulated_revenue, 0, None)

    monte_results.append({
        'neighbourhood_group_cleansed': neigh,
        'room_type': room,
        'avg_price_used': avg_price,
        'avg_nights_used': avg_nights,
        'simulated_mean_revenue': simulated_revenue.mean(),
        'simulated_std_revenue': simulated_revenue.std() })

simulated_only_df = pd.DataFrame(monte_results)
top_combinations = simulated_only_df.sort_values(by='simulated_mean_revenue', ascending=False).head(5)


plt.figure(figsize=(12, 8))

for idx, row in top_combinations.iterrows():
    simulated_revenue = np.random.normal(
        loc=row['avg_nights_used'], scale=5, size=1000
    ) * row['avg_price_used']
    simulated_revenue = np.clip(simulated_revenue, 0, None)
    sns.kdeplot(simulated_revenue, label=f"{row['neighbourhood_group_cleansed']} â€“ {row['room_type']}")

plt.title("Simulated Revenue Distributions (Top 5 Room Types by Mean Revenue)")
plt.xlabel("Simulated Annual Revenue ($)")
plt.ylabel("Density")
plt.legend(title="Listing Type")
plt.grid(True)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Set plot style
sns.set(style="whitegrid")

# Bar plot of simulated mean revenue
plt.figure(figsize=(14, 7))
sns.barplot(
    data=simulated_only_df,
    x="neighbourhood_group_cleansed",
    y="simulated_mean_revenue",
    hue="room_type",
    ci=None
)
plt.title("Simulated Annual Revenue by Neighborhood and Room Type (Predicted Pricing)")
plt.ylabel("Simulated Mean Revenue ($)")
plt.xlabel("Neighborhood Group")
plt.legend(title="Room Type", bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

# Error bar plot for standard deviation
plt.figure(figsize=(14, 7))
sns.barplot(
    data=simulated_only_df,
    x="neighbourhood_group_cleansed",
    y="simulated_mean_revenue",
    hue="room_type",
    ci=None,
    capsize=0.1
)

# Add standard deviation error bars manually
for i, row in simulated_only_df.iterrows():
    plt.errorbar(
        x=i % len(simulated_only_df['neighbourhood_group_cleansed'].unique()),
        y=row["simulated_mean_revenue"],
        yerr=row["simulated_std_revenue"],
        fmt='none',
        c='black',
        capsize=4
    )

plt.title("Simulated Revenue with Variability (Predicted Pricing)")
plt.ylabel("Simulated Mean Revenue ($)")
plt.xlabel("Neighborhood Group")
plt.legend(title="Room Type", bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()



import pandas as pd

df = pd.read_csv("nyc_cleaned_airbnb_NEWEST.csv")
print("Shape:", df.shape)
print("Columns:", df.columns.tolist())
df.head()

df = df[df['instant_bookable'].isin(['t', 'f'])]
print(df['instant_bookable'].unique())

print(df.columns.tolist())

df['instant_bookable'].value_counts(dropna=False)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# from sklearn.linear_model import LinearRegression
# from sklearn.preprocessing import StandardScaler, OneHotEncoder
# from sklearn.compose import ColumnTransformer
# from sklearn.pipeline import Pipeline
# 
# st.title("ðŸ“Š Airbnb Price and Revenue Estimator")
# 
# # user inputs
# borough = st.selectbox("Neighborhood Group", ["Brooklyn", "Manhattan", "Queens", "Bronx", "Staten Island"])
# room_type = st.selectbox("Room Type", ["Entire home/apt", "Private room", "Shared room", "Hotel room"])
# accommodates = st.slider("Accommodates", 1, 10, 2)
# bedrooms = st.slider("Bedrooms", 0, 5, 1)
# bathrooms = st.slider("Bathrooms", 0.5, 5.0, 1.0)
# beds = st.slider("Beds", 1, 5, 1)
# minimum_nights = st.slider("Minimum Nights", 1, 30, 3)
# availability_365 = st.slider("Availability (days per year)", 0, 255, 180)
# 
# # input row for prediction
# input_df = pd.DataFrame([{
#     'neighbourhood_group_cleansed': borough,
#     'room_type': room_type,
#     'accommodates': accommodates,
#     'bathrooms': bathrooms,
#     'bedrooms': bedrooms,
#     'beds': beds,
#     'minimum_nights': minimum_nights,
#     'availability_365': availability_365
# }])
# 
# df = pd.read_csv("nyc_cleaned_airbnb_NEWEST.csv")
# 
# required_cols = [
#     'neighbourhood_group_cleansed', 'room_type', 'accommodates', 'bathrooms',
#     'bedrooms', 'beds', 'minimum_nights', 'availability_365',
#     'price', 'estimated_nights_booked_365_model']
# df = df[required_cols].dropna()
# df = df[df['availability_365'] <= 255]
# 
# 
# X = df.drop(columns=['price', 'estimated_nights_booked_365_model'])
# y = df['price']
# 
# numeric_feats = ['accommodates', 'bathrooms', 'bedrooms', 'beds', 'minimum_nights', 'availability_365']
# cat_feats = ['neighbourhood_group_cleansed', 'room_type']
# 
# preprocessor = ColumnTransformer([
#     ('num', StandardScaler(), numeric_feats),
#     ('cat', OneHotEncoder(drop='first', sparse_output=False, handle_unknown='ignore'), cat_feats)
# ])
# 
# pipeline = Pipeline([
#     ('prep', preprocessor),
#     ('reg', LinearRegression())
# ])
# 
# pipeline.fit(X, y)
# predicted_price = pipeline.predict(input_df)[0]
# 
# #dynamically estimated booking
# filtered = df[(df['neighbourhood_group_cleansed'] == borough) & (df['room_type'] == room_type)]
# 
# if not filtered.empty:
#     avg_nights = filtered['estimated_nights_booked_365_model'].mean()
# else:
#     avg_nights = 27
# 
# #Monte Carlo
# simulated_revenue = np.random.normal(loc=avg_nights, scale=5, size=1000) * predicted_price
# simulated_revenue = np.clip(simulated_revenue, 0, None)
# 
# 
# st.subheader("ðŸ’° Pricing & Revenue Forecast")
# st.write(f"**Recommended Nightly Price**: ${predicted_price:.2f}")
# st.write(f"**Simulated Annual Revenue**: ${simulated_revenue.mean():.2f}")
# st.write(f"**Revenue Range (Â±1 SD)**: ${simulated_revenue.mean() - simulated_revenue.std():.2f} â€“ ${simulated_revenue.mean() + simulated_revenue.std():.2f}")
#

from pyngrok import ngrok
import threading
import os

def run_app():
    os.system("streamlit run app.py")

threading.Thread(target=run_app).start()

# Expose on public URL
public_url = ngrok.connect(8501)
print("Streamlit app available at:", public_url)
